# ES2015+ (ES6)

## 2.1.1 const, let

```javascript
if (true) {
    var x = 3;
}
console.log(x);

//
if (true) {
    const y = 3;
}
console.log(y);
```

* var는 함수 스코프를 가지므로 if문 블록과 상관없이 어디서나 접근 가능.

* const와 let은 블록({}) 스코프를 가지므로 블록 밖에서는 접근 불가. 범위는 블록 안.

* const는 한 번 값을 할당하면 다른값 할당 불가. 
    * const는 상수라고도 함 .
    * let은 사용 가능.

* 변수 선언시에는 기본적으로 const 사용, 다른 값 할당해야 하는 상황시 let 사용 

## 2.1.2 템플릿 문자열 

* `${변수명}` 으로 사용 가능 ``백틱안에 넣어 사용 

```javascript

const num1 = 1;
const num2 = 2;

const string2 = `${num1} 더하기 ${num2} 는?`;

```



## 2.1.3 객체리터럴

* 객체의 메서드에 :funtion을 붙이지 않아도 됨

* {sayNode : sayNode} 와 같은것을 {sayNode}로 축약 가능

* [변수 + 값] 등으로 동적 속성명을 객체 속성명으로 사용 가능

```javascript
const newObject = {
    sayJS() {
        console.log('js');
    }, 
    sayNode,
    [es + 6]: 'Fantastic',
};

newObject.sayNode(); // Node
newObject.sayJS(); // JS
console.log(newObject.ES6); // Fantastic 

```

## 2.14 화살표 함수(arrow function)

```javascript
function add1(x, y) {
    return x + y;
}

const add2 = (x, y) => {
    return x + y;
}

const add3 = (x, y) => x + y;

const add4 = (x, y) => (x + y);

function not1(x) {
    return !x;
}

const not2 = x => !x;

```

* add2 : add1을 화살표 함수로 나타낼 수 있음

* add3 : 함수의 본문이 return만 있는 경우 return 생략

* add4 : return이 생략된 함수의 본문을 소괄호로 감싸줄 수 있음

* not1과 not2도 같은 기능을 함 ( 매개변수 하나일때는 괄호 생략)


```javascript
var relationship1 = {
    name: 'zero',
    friends: ['nero', 'hero', 'xero'],
    logFriends: function() {
        var that = this;
        this.friends.forEach(function (friend) {
            console.log(that.name, friend);
        });
    }
}

relationship1.logFriends();

const relationship2 = {
    name : 'zero',
    friends: ['nero', 'hero', 'xero'],
    logFriends() {
        this.friends.forEach(friend => {
            console.log(this.name, friend);
        });
    },
};

relatioship2.logFriends();
```


* relationship1의 forEach문에서는 that이라는 변수를 사용해서 relationship1에 간접적으로 접근.

* relationship2의 forEach문에서는 arrow function을 사용해서 logFriends의 this를 그대로 사용
    * 즉 상위 스코프의 this를 그대로 물려 받는 것 

* 기본적으로 arrow function을 쓰되, this를 사용해야 하는 경우 에는 arrow function을 쓰고 아니면 물려받고 싶지 않을 때는 function을 쓰면 된다. 


## 2.1.5 구조분해 할당

* 구조분해 할당을 사용하면 객체와 배열로부터 속성이나 요소를 쉽게꺼낼 수 있다.












