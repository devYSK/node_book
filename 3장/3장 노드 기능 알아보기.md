
## 3.1 REPL 사용하기

* 입력한 코드를 읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 반복한다(Loop) => REPL
* 터미널애서 노드 사용하면 콘솔처림 사용 가능. 명령어 : node

## 3.2 JS파일 실행하기

* 콘솔에서 node [자바스크립트 파일 경로]로 실행. .js는 생략 가능 

## 3.3 모듈 만들기

```javascript

// var.js
const odd = '홀수입니다';
const even = '짝수입니다';

module.exports = {
    odd,
    even,
};


//-------------------------------------------

// func.js
const { odd, even} = require('/.var');

function checkOddOrEven(num) {
    if (num % 2 ) {
        return odd;
    }
    
    return even;
}

module.exports = checkOddOrEven;

//------------------

// index.js
const { odd, even} = require('./var');
const checkNumber = require('./func');

function checkStringOddOrEven(str) {
    if (str.length % 2) {
        return odd;
    }

    return even;
}

console.log(checkNumber(10));
console.log(checkStringOddOrEven('hello'));

```

* require 함수 안에 불러올 모듈의 경로를 적는다 확장자는 생략 가능

* var.js의 mudule.exports에 담겨 있던 객체를 불러와 func.js에서 사용 

* ES6에서 모듈 문법이 바뀌었다. 

```javascript
// func.js


//const { odd, even} = require('/.var');
import { odd, even} = from './var';

function checkOddOrEven(num) {
    if (num % 2 ) {
        return odd;
    }
    
    return even;
}

export default checkOddOrEven;
```

* require와 module.exports가 import, export default로 바뀌었다.
    * require -> import ~ from
    * module.exports -> export default 


## 3.4 노드 내장 객체 알아보기 

* 따로 설치 않아도 되는 브라우저의 window 같은 객체 .

## 3.4.1 global

* window와 같은 전역 객체. 
    * window.open 메서드를 그냥 open으로 호출할 수 있는 것처럼 global도 생략 가능 
    * require 함수도 global.require에서 global을 생략한 것 
    * console 객체도 원래는 global.console

* node 콘솔에 global 이라 치면 속성이 나온다. 

* global.message = '히히'; 등을 이용해서 객체에 넣어서 전역(다른파일 등)에서 쓸 수 있다. 
    * 남용하면 안된다. 유지 보수에 어려움을 겪기 때문에 다른 파일의 값을 쓰고 싶으면 모듈형식으로 만들자. 

## 3.4.2 console

* 노드에서는 window 대신 global 객체 안에 들어있다

* 여기서 표현하는 레이블이란, 단어나 키워드 같이 단어 관련말임. 

* console.time(레이블): console timeEnd(레이블) 과 대응되어 `같은 레이블`을 가진 time과 timeEnd 사이의 시간 측정
    * ```javascript
      console.time('시간 측정!');
      for (let i = 0; i < 100000; i++>) {}
      console.timeEnd('시간 측정!');
      ```

* console.error(에러 내용) : 에러 콘솔에 표시

* console.table(배열) : 배열의 요소로 객체 리터럴을넣으면 객체의 속성들이 테이블 형식으로 표현

* console.dir(객체, 옵션) : 객체를 콘솔에 표현시 사용.
    * 첫 번째 인수로 객체, 두 번째 인수로 옵션
    * 옵션의 colors를 true로 하면 콘솔에 색이 추가되어 보기가 편해짐.
    * 옵션의 depth는 몇 단계 까지 보여줄지를 결정. 기본값은 2 
    * ```javascript
      console.dir(obj, {colors : false, depth : 5}); // 이런식으로 사용 
      ```

* console.trace(레이블) : 에러가 어디서 발생했는지 추적할 수 있게 함. 에러 위치 알기위해 사용

* 메서드들은 계속 추가되는중이다. 


## 3.4.3 타이머
* global 객체 안에 setTimeout, setInterval, setImmeidiate 가 있다.

* setTimeout(콜백 함수, 밀리초) : 주어진 밀리초(1000분의 1초, 1000 = 1초) 이후에 콜백 함수 실행

* setInterval(콜백 함수, 밀리초) : 주어진 밀리초마다 콜백 함수 반복

* setImmediate(콜백함수) : 콜백 함수 즉시 실행

* 이 타이머 함수들은 모두 아이디를 반환한다. 아이디를 사용하여 타이머 취소 가능

* clearTimeout(아이디) : setTimeout 취소

* clearInterval(아이디) : setInterval 취소

* clearImmediate(아이디) : setImmediate를 취소

```javascript
const timeout = setTimeout(() => {
    console.log('1.5초후 실행');
}, 1500);

const interval = setInterval(() => {
    console.log('1초마다 실행');
}, 1000);


setTimeout(() => {
    clearTimeout(timeout);
    clearInterval(interval);
}, 2500); // 2500 밀리초 뒤에 실행  

```

* setTimeout(콜백함수, 0)은 사용하지 않는것을 권장. 


## 3.4.4 __filename, __dirname

* 노드는 __filename과 __dirname 키워드로 현재 파일의 경로, 파일명에 대한 정보 제공

* /나 \ 같은 경로 구분자는 path 모듈로 해결할 수 있다. (3.5.2절 참조)

## 3.4.5 module, exports, require 

* module 객체 말고 exports 객체로도 모듈을 만들 수 있다.

* 각각의 변수를 exports 객체에 넣으면 된다. ex) exports.변수명 = '히힛'; 

* module.exports와 exports 객체가 `같은 객체를 참조` 한다.
    * 그러므로 exports 객체에 변수나 함수를 넣으면, module.exports 객체에도 들어간다 .
    * ![](images/2021-08-08-19-43-01.png)

* exports와 module.exports 를 한 모듈에서 동시에 사용하지 않는것이 좋다. 


`### 노드에서의 this`

* 최상위 스코프에 존재하는 this는 module.exports(또는 exports) 객체를 가리키고, 함수 선언문 내부의 this는 global 객체를 가리킨다  


* require는 파일 최상단에 위치할 필요가 없고, 최하단에 위치할 필요가 없다. 아무곳에서나 사용해도 된다. 


* require.cache 객체에는 파일 이름이 속성명으로 들어있다. 속성값으로 각 파일의 모듈 객체가 들어 있다.
    * 한번 require한 파일은 require.cache에 저장되고 다음번에 require할 때는 새로 불러오지 않고 require.cache에 있는 것이 재 사용된다.

    * 만약 새로 require하길 원한다면, require.cache 속성을 제거하면 된다. 하지만 프로그램이 꼬일 수 잇다.

* require.main은 노드 실행시 첫 모듈을 가리킨다. 
    * require.js 파일을 실행했으므로 require.js가 require.main이 된다. 
    * require.main 객체의 모양은 require.cache의 `모듈 객체`와 같다. 


* 두 모듈이 서로를 참조할 때 `순환 참조`가 발생할 수 잇다. 그러면 module.exports 함수가 빈 객체로 표시되기 때문에 순환참조 하지 않도록 구조를 잘 잡아야 한다. 


## 3.4.6 process

* process 객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고 있다.

* process.version : 노드 버전

* process.arch : 프로세서 아키텍처 정보. x64, arm 등 

* process.platform : 운영체제 정보 win32, mac, linux 등 

* process.pid : 프로세스 아이디

* process.uptime() : 프로세스가 시작된 후 흐른 시간. 단위는 초

* process.execPath : 노드의 경로 

* process.cwd() : 현재 프로세스가 실행되는 위치

* process.cpuUsage() : 현재 cpu 용량 

### 중요한 프로세스 변수.

* process.env 